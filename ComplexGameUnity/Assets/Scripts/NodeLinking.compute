// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel Distance


//----------DATA-------------
struct NodePosition
{
    float3 position;
};
struct NodeEdge
{
    int connection1;
    int connection2;
    int connection3;
    int connection4;
    int connection5;
    int connection6;
    float connection1Cost;
    float connection2Cost;
    float connection3Cost;
    float connection4Cost;
    float connection5Cost;
    float connection6Cost;
};
int nodeAmount;
RWStructuredBuffer<NodePosition> nodePositions;
RWStructuredBuffer<NodeEdge> nodeConnections;
//----------------------------

//Divide the node amount by 32 for the amount of dispatches needed (32 is nvidia and 64 is amd so
//for ease of use we use 32)
[numthreads(32,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    
}

//this will be split between nodes
[numthreads(1, 1, 1)]
void Distance(uint3 id : SV_DispatchThreadID)
{
    if (nodeConnections[id.x].connection1 != -1)
    {
        nodeConnections[id.x].connection1Cost = sqrt(distance(nodePositions[id.x].position, nodePositions[nodeConnections[id.x].connection1].position));
    }
    if (nodeConnections[id.x].connection2 != -1)
    {
        nodeConnections[id.x].connection2Cost = sqrt(distance(nodePositions[id.x].position, nodePositions[nodeConnections[id.x].connection2].position));
    }
    if (nodeConnections[id.x].connection3 != -1)
    {
        nodeConnections[id.x].connection3Cost = sqrt(distance(nodePositions[id.x].position, nodePositions[nodeConnections[id.x].connection3].position));
    }
    if (nodeConnections[id.x].connection4 != -1)
    {
        nodeConnections[id.x].connection4Cost = sqrt(distance(nodePositions[id.x].position, nodePositions[nodeConnections[id.x].connection4].position));
    }
    if (nodeConnections[id.x].connection5 != -1)
    {
        nodeConnections[id.x].connection5Cost = sqrt(distance(nodePositions[id.x].position, nodePositions[nodeConnections[id.x].connection5].position));
    }
    if (nodeConnections[id.x].connection6 != -1)
    {
        nodeConnections[id.x].connection6Cost = sqrt(distance(nodePositions[id.x].position, nodePositions[nodeConnections[id.x].connection6].position));
    }

}


//this will have to be a kernal for  the one agents path because dividing all this is going to be horrible
//rather then seeing how to split the work and do it per agent (i could have it just do 4 threads per agent asking)
