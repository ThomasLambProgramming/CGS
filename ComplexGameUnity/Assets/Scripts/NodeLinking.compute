// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Linker
#pragma kernel FindClosest

/*
    Divide node amount by 64 (we want thread groups of 64)
    this tells us how many thread groups we want
    amd can support 128 but nvidia is a bit weird with it so keeping to 64 is nice for both

    new node = index in array (can also be id), position
    edgeConnections = to this node, cost
*/

//the nodeid will be the index of the node
class Edge
{
    
};
class Node
{
    float3 position;
    //memory in shaders sucks
    int nodeId[6];
    float cost[6];
};
class PathNode
{
    float m_totalCost;
    float m_gCost;
    float m_hCost;
    float m_fCost;
    Node m_node;
    Node m_parent;
};

RWStructuredBuffer<Node> nodes;

//i want each thread to check against one node
[numthreads(1,1,1)]
void Linker(uint3 id : SV_DispatchThreadID)
{

}

//groupshared allows each thread to share some memory 
groupshared float minDistance = 1000;
groupshared int currentIndex = 0;

RWStructuredBuffer<int> nodeIndex;
float3 findPosition;
[numthreads(1, 1, 1)]
void FindClosest(uint3 id : SV_DispatchThreadID)
{
    
    float x = nodes[id.x].position.x - findPosition.x;
    float y = nodes[id.x].position.y - findPosition.y;
    float z = nodes[id.x].position.z - findPosition.z;

    float nodeDistance = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));

    
    if (nodeDistance < minDistance)
    {
        minDistance = nodeDistance;
        currentIndex = id.x;
        nodeIndex[0] = currentIndex;
    }
}

