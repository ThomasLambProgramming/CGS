//// Each #kernel tells which function to compile; you can have many kernels
//#pragma kernel CSMain
//#pragma kernel Distance
//
//
////----------DATA-------------
//struct NodePosition
//{
//    float3 position;
//};
//struct NodeEdge
//{
//    int connection1;
//    int connection2;
//    int connection3;
//    int connection4;
//    int connection5;
//    int connection6;
//    float connection1Cost;
//    float connection2Cost;
//    float connection3Cost;
//    float connection4Cost;
//    float connection5Cost;
//    float connection6Cost;
//};
//struct PathNode
//{
//    float totalCost;
//    float gCost;
//    float hCost;
//    float fCost;
//    NodePosition pos;
//    NodeEdge connections;
//};
//
////this is terrible but they all have to be seperated because it cant have a reference to its own type in a struct
//struct PathfindingNode
//{
//    PathNode node;
//    //array index of parent in listarray whatever it is
//    int parent;
//};
//
//
//int nodeAmount;
//RWStructuredBuffer<NodePosition> nodePositions;
//RWStructuredBuffer<NodeEdge> nodeConnections;
//
////indexes to the starting and ending node
//int startNode;
//int endNode;
////----------------------------
//
//
//[numthreads(1,0,0)]
//void CSMain (uint3 id : SV_DispatchThreadID)
//{
//    //ASTAR IMPLEMENTATION
//    //Get the closest node to start position and end position (just use the cpu side version with an index)
//
//    //these hardcoded values need to be high initially and then trial and error for each application to see what the "magic number" needed is
//    PathfindingNode openNodes[300];
//    PathfindingNode closedNodes[600];
//
//    PathfindingNode start;
//    NodePosition end;
//
//    start.node.pos = nodePositions[startNode];
//    start.node.connections = nodeConnections[startNode];
//    start.node.gCost = 0;
//    start.node.hCost = distance(nodePositions[endNode].position, nodePositions[startNode].position);
//    openNodes[0] = start;
//    //since dynamic arrays cant be done i need to have a que system and know where the start and end are so no overlap is done.
//    int queStart = 0;
//    int queEnd = 1;
//
//    
//    while (queStart != queEnd)
//    {
//        PathfindingNode currentNode = openNodes[queStart];
//    }
//
//
//
//
//
//}
